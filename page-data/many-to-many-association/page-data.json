{"componentChunkName":"component---src-templates-post-js","path":"/many-to-many-association","webpackCompilationHash":"11c2b823418232876bb5","result":{"data":{"markdownRemark":{"html":"<p>To setup a basic many-to-many associations, we need to start by declaring the needed models withing the rails console. We need three models for this purpose. Two tables with a regular ID field and one table with its ID field along with the ID fields of each of the other tables. This table serves the purpose of a joining table (a.ka. Join Table or Pivot Table). The many-to-many association is really</p>\n<p>Just two one-to-many associations with a joining table in the middle as demonstrated in the table diagram below.</p>\n<h4>From the rails console create the needed models:</h4>\n<pre><code class=\"language-ruby\">  rails g model Product\n  rails g mdoel Satisfaction\n  rails g model Buyer\n</code></pre>\n<p>This will create three model and migration files. Open each of the migration files and added the needed fields so they can be created with a <code>rails db:migrate</code> command.</p>\n<h4>Product Migration</h4>\n<pre><code class=\"language-ruby\">  class CreateProducts &#x3C; ActiveRecord::Migration[5.0]\n    def change\n      create_table :products do |t|\n        t.string :name\n        t.date :manufacture_date\n        t.timestamps\n      end\n    end\n  end\n</code></pre>\n<h4>Satisfaction Migration</h4>\n<pre><code class=\"language-ruby\">  class CreateSatisfactions &#x3C; ActiveRecord::Migration[5.0]\n    def change\n      create_table :satisfactions do |t|\n        t.integer :rank\n        t.references :product, foreign_key: true\n        t.references :buyer, foreign_key: true\n        t.timestamps\n      end\n    end\n  end\n</code></pre>\n<h4>Buyer Migration</h4>\n<pre><code class=\"language-ruby\">  class CreateBuyers &#x3C; ActiveRecord::Migration[5.0]\n    def change\n      create_table :buyers do |t|\n        t.string :name\n        t.string :age\n        t.date :buy_date\n        t.timestamps\n      end\n    end\n  end\n</code></pre>\n<h4>This will setup the following tables</h4>\n<table>\n<thead>\n<tr>\n<th>product</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>name</td>\n<td>manufacture_date</td>\n<td>created_at</td>\n<td>updated_at</td>\n</tr>\n</tbody>\n</table>\n<p>The <code>product_id</code> is a foreign key pointing to the 'products' table and the <code>buyer_id</code> is a foreign key pointing to the 'buyers' table.</p>\n<table>\n<thead>\n<tr>\n<th>satisfactions</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>rank</td>\n<td>product_id</td>\n<td>buyer_id</td>\n<td>created_at</td>\n<td>updated_at</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>buyers</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>name</td>\n<td>age</td>\n<td>buy_date</td>\n<td>created_at</td>\n<td>updated_at</td>\n</tr>\n</tbody>\n</table>\n<p>At this point, we need to setup the necessary associations within the model files. This can be accomplished by added the <code>belongs_to</code> and <code>has_many</code> lines listed int the model files below.</p>\n<h4>Product Model:</h4>\n<pre><code class=\"language-ruby\">  class Product &#x3C; ApplicationRecord\n    has_many :satisfactions\n  end\n</code></pre>\n<h4>Satisfaction Model:</h4>\n<pre><code class=\"language-ruby\">  class Satisfaction &#x3C; ApplicationRecord\n    belongs_to :product\n    belongs_to :buyer\n  end\n</code></pre>\n<h4>Buyer Model:</h4>\n<pre><code class=\"language-ruby\">  class Buyer &#x3C; ApplicationRecord\n    # The 'dependent: :destroy' says to destroy the satisfaction\n    # ranking for that buyer when the buyer is removed:\n    has_many :satisfactions, dependent: :destroy\n  end\n</code></pre>\n<p>If we open up the rails console with <code>rails c</code>, then we have the following relationships available to us:</p>\n<pre><code class=\"language-ruby\">  prod = Product.create(name: \"Dell Inspiron\")\n  buy = Buyer.create(name: \"Joe\", buy_date: \"2017-07-04\")\n\n  sat = Satisfaction.new\n  sat.rank = 4\n  sat.product = prod\n  sat.buyer = buy\n  sat.save\n\n  # Then we can also print the product's satisfaction rankings:\n  prod.satisfactions\n\n  # Also, we can print the buyers satisfaction rankings:\n  buy.satisfactions\n</code></pre>\n<p>With this relationship setup we can create new satisfaction ranking like this:</p>\n<pre><code class=\"language-ruby\">    prod = Product.first\n    buy = Buyer.find_by(name: \"Joe\")\n    sat = prod.satisfactions.new(rank: 2)\n    sat.buyer = buy\n    sat.save\n</code></pre>\n<p>In addition, we could also setup the buyer and product for the new satisfaction ranking in one fell swoop:</p>\n<pre><code class=\"language-ruby\">  prod = Product.first\n  buy = Buyer.first\n  prod.satisfactions.create!(rank: 5, buyer: buy)\n</code></pre>\n<p>Using these tables, we can find the buyers for a product like this:</p>\n<pre><code class=\"language-ruby\">  # Find the product:\n  prod = Product.first\n\n  # Find satisfaction rankings attached to the product we just queried:\n  # 'sat' now holds an array list of satisfaction rank objects\n  sat = prod.satisfactions\n\n  # Now we can use a loop to get the 'buyer' associated with each satisfaction like this:\n  # This results in 1+n queries:\n  sat.each { |s| s.buyer.name }\n\n  # This will end up running some queries like this:\n  # SELECT  \"buyers\".* FROM \"buyers\" WHERE \"buyers\".\"id\" = ? LIMIT ?\n  # SELECT  \"buyers\".* FROM \"buyers\" WHERE \"buyers\".\"id\" = ? LIMIT ?\n  # SELECT  \"buyers\".* FROM \"buyers\" WHERE \"buyers\".\"id\" = ? LIMIT ?\n  # SELECT  \"buyers\".* FROM \"buyers\" WHERE \"buyers\".\"id\" = ? LIMIT ?\n  # SELECT  \"buyers\".* FROM \"buyers\" WHERE \"buyers\".\"id\" = ? LIMIT ?\n</code></pre>\n<p>Instead of having to get a list of the satisfaction rankings assigned to a particular product, and then loop through each one to find the user associated with each one (1+n queries), we can instead use a through association with rails. This will drastically reduce the number of queries that are necessary.</p>\n<p>To setup a through association for our current example, we can add this to the 'Product' model:</p>\n<h4>Product Model:</h4>\n<pre><code class=\"language-ruby\">  class Product &#x3C; ApplicationRecord\n    has_many :satisfactions\n\n    # Add this line:\n    has_many :buyers, through: :satisfactions\n  end\n\n  # This will allow this query:\n  p = Product.first\n  p.buyers\n\n  # Resultant query:\n  # SELECT \"buyers\".* FROM \"buyers\" INNER JOIN \"satisfactions\" ON \"buyers\".\"id\" = \"satisfactions\".\"buyer_id\" WHERE \"satisfactions\".\"product_id\" = ?\n</code></pre>\n<p>To setup the reverse of this relationship, we can add the line below to the 'Buyer' model:</p>\n<h4>Buyer Model:</h4>\n<pre><code class=\"language-ruby\">  class Buyer &#x3C; ApplicationRecord\n    has_many :satisfactions, dependent: :destroy\n    has_many :products, through: :satisfactions\n  end\n\n  # This will allow this query:\n  buy = Buyer.first\n  buy.products\n</code></pre>\n<p>We can even abbreviate the name of our through association relationship by adding a 'source' declaration and changing our 'Product' model as listed below:</p>\n<h4>Product Model:</h4>\n<pre><code class=\"language-ruby\">  class Product &#x3C; ApplicationRecord\n    has_many :satisfactions\n\n    # Add this line:\n    has_many :purchasers, through: :satisfactions, source: :buyer\n  end\n\n  # Now we can do this:\n  p = Product.first\n  p.purchasers\n\n  # SQL:\n  # SELECT \"buyers\".* FROM \"buyers\" INNER JOIN \"satisfactions\" ON \"buyers\".\"id\" = \"satisfactions\".\"buyer_id\" WHERE \"satisfactions\".\"product_id\" = ?\n</code></pre>\n<p>We can do the same thing in the reverse as well, by modifying the 'Buyer' model file:</p>\n<pre><code class=\"language-ruby\">  class Buyer &#x3C; ApplicationRecord\n    has_many :satisfactions, dependent: :destroy\n    has_many :things, through: :satisfactions, source: :product\n\n    # This allows for:\n    b = Buyer.first\n    b.things\n\n    # SQL:\n    # SELECT \"products\".* FROM \"products\" INNER JOIN \"satisfactions\" ON \"products\".\"id\" = \"satisfactions\".\"product_id\" WHERE \"satisfactions\".\"buyer_id\" = ?\n  end\n</code></pre>\n<p>I have included the code for this mvc application in this repo:\n<a href=\"https://github.com/joshayoung/many-to-many-rails&#x27;%3Emany-to-many-rails\">many-to-many-rails</a>.</p>","frontmatter":{"date":"May 26, 2018","path":"/many-to-many-association","title":"Many-to-Many Association in Rails"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}