{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/docker-run-command",
    "result": {"data":{"markdownRemark":{"html":"<p>The <code>docker run</code> command is used to create a container from an image. It can be executed in a few different ways to provide images in different formats.</p>\n<h5>Create a Persistent Container:</h5>\n<ul>\n<li><code>docker container run --name my-postgres -e POSTGRES_PASSWORD=password -d postgres</code>\n<ul>\n<li>Here I am creating a container named 'my-postgres'. This container will exist on my local file system and can be started/stopped at will.</li>\n<li>Because I have used the <code>-d</code> flag the container will be started in the background.</li>\n</ul>\n</li>\n<li>You can see the container by running:\n<ul>\n<li><code>docker container ls | grep my-postgres</code>.</li>\n</ul>\n<pre><code class=\"language-bash\">1234567890 postgres \"docker-entrypoint.sâ€¦\" 27 seconds ago Up 26 seconds 5432/tcp my-postgres\n</code></pre>\n</li>\n<li>Now we can attach to it with a bash shell:\n<ul>\n<li><code>docker exec -it my-postgres bash</code>.\n<ul>\n<li>From inside this shell we can run a program (like <code>psql</code> in this case).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Start a container with the psql shell:\n<ul>\n<li><code>docker exec -it my-postgres psql -U postgres</code>\n<ul>\n<li>I should be in an interactive <code>psql</code> session within my container.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5>Create a Temporary Container:</h5>\n<p>Each time we execute the run command and specify a <code>--name</code> flag, we create a container by that name on our host. Therefore, if we run our docker <code>run</code> command again, we will get an error to the effect of: 'this container already exists'. We can circumvent this issue kby specifying a different value for the <code>--name</code> flag. Alternatively, we can also use the <code>--rm</code> flag.</p>\n<ul>\n<li><code>docker container run --name my-postgres -it --rm -e POSTGRES_PASSWORD=password postgres bash</code>\n<ul>\n<li>Here I get an interactive temporary container that will not be saved to my file system upon exit.</li>\n</ul>\n</li>\n<li><code>docker container run --name my-postgres --rm -e POSTGRES_PASSWORD=password -d postgres</code>\n<ul>\n<li>Here I am starting my new container in the background. It will exist until it is stopped. At which point it will be deleted due to the <code>--rm</code> flag.</li>\n</ul>\n</li>\n</ul>\n<h5>Interactive Session:</h5>\n<ul>\n<li>As noted above, using <code>-it</code> and passing a shell to the container like: <code>bash</code> will allow me to connect to a shell instance inside my running container.</li>\n<li><code>docker container run --name my-postgres -it --rm -e POSTGRES_PASSWORD=password postgres bash</code></li>\n<li>If you are debugging an application like rails for instance and want to use a debugger, make sure you specify the <code>-it</code>. Otherwise you may spend a lot of time trying to determine why your server sessions is running but not hitting any of your breakpoints. I speak from experience :)</li>\n</ul>\n<h5>Connect to Your Running Container from your Host:</h5>\n<ul>\n<li>If I expose the container's listen port to my host machine via the <code>-p</code> flag, then I can connect to the running server on my container from a program on my host.</li>\n<li><code>docker container run --name my-postgres -p 5433:5432 -it --rm -e POSTGRES_PASSWORD=password -d postgres</code>\n<ul>\n<li>Here I am saying expose port 5432 to my host via port 5433.</li>\n<li>I now should be able to use any postgres gui client installed on my laptop to connect to the running postgres server in my container.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"February 22, 2021","path":"/docker-run-command","title":"Docker Run Command"}}},"pageContext":{}},
    "staticQueryHashes": ["305197398"]}