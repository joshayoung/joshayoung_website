
<!doctype html>
<html lang="en">
    <head>
        <link rel="stylesheet" href="./style.css">
    </head>
    <body>
        <heaer>
            <h1>Docker Run Command</h1>
        </heaer>
    </body>
    <main>
<p>The <code>docker run</code> command is used to create a container from an image. It can be executed in a few different ways to provide images in different formats.</p>
<h5>Create a Persistent Container:</h5>
<ul>
<li><code>docker container run --name my-postgres -e POSTGRES_PASSWORD=password -d postgres</code>
<ul>
<li>Here I am creating a container named 'my-postgres'. This container will exist on my local file system and can be started/stopped at will.</li>
<li>Because I have used the <code>-d</code> flag the container will be started in the background.</li>
</ul>
</li>
<li>You can see the container by running:
<ul>
<li><code>docker container ls | grep my-postgres</code>.</li>
</ul>
<pre><code class="language-bash">1234567890 postgres &quot;docker-entrypoint.sâ€¦&quot; 27 seconds ago Up 26 seconds 5432/tcp my-postgres
</code></pre>
</li>
<li>Now we can attach to it with a bash shell:
<ul>
<li><code>docker exec -it my-postgres bash</code>.
<ul>
<li>From inside this shell we can run a program (like <code>psql</code> in this case).</li>
</ul>
</li>
</ul>
</li>
<li>Start a container with the psql shell:
<ul>
<li><code>docker exec -it my-postgres psql -U postgres</code>
<ul>
<li>I should be in an interactive <code>psql</code> session within my container.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5>Create a Temporary Container:</h5>
<p>Each time we execute the run command and specify a <code>--name</code> flag, we create a container by that name on our host. Therefore, if we run our docker <code>run</code> command again, we will get an error to the effect of: 'this container already exists'. We can circumvent this issue by specifying a different value for the <code>--name</code> flag. Alternatively, we can also use the <code>--rm</code> flag.</p>
<ul>
<li><code>docker container run --name my-postgres -it --rm -e POSTGRES_PASSWORD=password postgres bash</code>
<ul>
<li>Here I get an interactive temporary container that will not be saved to my file system upon exit.</li>
</ul>
</li>
<li><code>docker container run --name my-postgres --rm -e POSTGRES_PASSWORD=password -d postgres</code>
<ul>
<li>Here I am starting my new container in the background. It will exist until it is stopped. At which point it will be deleted due to the <code>--rm</code> flag.</li>
</ul>
</li>
</ul>
<h5>Interactive Session:</h5>
<ul>
<li>As noted above, using <code>-it</code> and passing a shell to the container like: <code>bash</code> will allow me to connect to a shell instance inside my running container.</li>
<li><code>docker container run --name my-postgres -it --rm -e POSTGRES_PASSWORD=password postgres bash</code></li>
<li>If you are debugging an application like rails for instance and want to use a debugger, make sure you specify the <code>-it</code>. Otherwise you may spend a lot of time trying to determine why your server sessions is running but not hitting any of your breakpoints. I speak from experience :)</li>
</ul>
<h5>Connect to Your Running Container from your Host:</h5>
<ul>
<li>If I expose the container's listen port to my host machine via the <code>-p</code> flag, then I can connect to the running server on my container from a program on my host.</li>
<li><code>docker container run --name my-postgres -p 5433:5432 -it --rm -e POSTGRES_PASSWORD=password -d postgres</code>
<ul>
<li>Here I am saying expose port 5432 to my host via port 5433.</li>
<li>I now should be able to use any postgres gui client installed on my laptop to connect to the running postgres server in my container.</li>
</ul>
</li>
</ul>
 blas
    </main>
</html>
