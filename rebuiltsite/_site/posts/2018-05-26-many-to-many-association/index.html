
<!doctype html>
<html lang="en">
    <head>
        <link rel="stylesheet" href="./style.css">
    </head>
    <body>
        <heaer>
            <h1>Many-to-Many Association in Rails</h1>
        </heaer>
    </body>
    <main>
<p>To setup a basic many-to-many associations, we need to start by declaring the needed models withing the rails console. We need three models for this purpose. Two tables with a regular ID field and one table with its ID field along with the ID fields of each of the other tables. This table serves the purpose of a joining table (a.ka. Join Table or Pivot Table). The many-to-many association is really</p>
<p>Just two one-to-many associations with a joining table in the middle as demonstrated in the table diagram below.</p>
<h4>From the rails console create the needed models:</h4>
<pre><code class="language-ruby">  rails g model Product
  rails g mdoel Satisfaction
  rails g model Buyer
</code></pre>
<p>This will create three model and migration files. Open each of the migration files and added the needed fields so they can be created with a <code>rails db:migrate</code> command.</p>
<h4>Product Migration</h4>
<pre><code class="language-ruby">  class CreateProducts &lt; ActiveRecord::Migration[5.0]
    def change
      create_table :products do |t|
        t.string :name
        t.date :manufacture_date
        t.timestamps
      end
    end
  end
</code></pre>
<h4>Satisfaction Migration</h4>
<pre><code class="language-ruby">  class CreateSatisfactions &lt; ActiveRecord::Migration[5.0]
    def change
      create_table :satisfactions do |t|
        t.integer :rank
        t.references :product, foreign_key: true
        t.references :buyer, foreign_key: true
        t.timestamps
      end
    end
  end
</code></pre>
<h4>Buyer Migration</h4>
<pre><code class="language-ruby">  class CreateBuyers &lt; ActiveRecord::Migration[5.0]
    def change
      create_table :buyers do |t|
        t.string :name
        t.string :age
        t.date :buy_date
        t.timestamps
      end
    end
  end
</code></pre>
<h4>This will setup the following tables</h4>
<table>
<thead>
<tr>
<th>product</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>name</td>
<td>manufacture_date</td>
<td>created_at</td>
<td>updated_at</td>
</tr>
</tbody>
</table>
<p>The <code>product_id</code> is a foreign key pointing to the 'products' table and the <code>buyer_id</code> is a foreign key pointing to the 'buyers' table.</p>
<table>
<thead>
<tr>
<th>satisfactions</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>rank</td>
<td>product_id</td>
<td>buyer_id</td>
<td>created_at</td>
<td>updated_at</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>buyers</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>name</td>
<td>age</td>
<td>buy_date</td>
<td>created_at</td>
<td>updated_at</td>
</tr>
</tbody>
</table>
<p>At this point, we need to setup the necessary associations within the model files. This can be accomplished by added the <code>belongs_to</code> and <code>has_many</code> lines listed int the model files below.</p>
<h4>Product Model:</h4>
<pre><code class="language-ruby">  class Product &lt; ApplicationRecord
    has_many :satisfactions
  end
</code></pre>
<h4>Satisfaction Model:</h4>
<pre><code class="language-ruby">  class Satisfaction &lt; ApplicationRecord
    belongs_to :product
    belongs_to :buyer
  end
</code></pre>
<h4>Buyer Model:</h4>
<pre><code class="language-ruby">  class Buyer &lt; ApplicationRecord
    # The 'dependent: :destroy' says to destroy the satisfaction
    # ranking for that buyer when the buyer is removed:
    has_many :satisfactions, dependent: :destroy
  end
</code></pre>
<p>If we open up the rails console with <code>rails c</code>, then we have the following relationships available to us:</p>
<pre><code class="language-ruby">  prod = Product.create(name: &quot;Dell Inspiron&quot;)
  buy = Buyer.create(name: &quot;Joe&quot;, buy_date: &quot;2017-07-04&quot;)

  sat = Satisfaction.new
  sat.rank = 4
  sat.product = prod
  sat.buyer = buy
  sat.save

  # Then we can also print the product's satisfaction rankings:
  prod.satisfactions

  # Also, we can print the buyers satisfaction rankings:
  buy.satisfactions
</code></pre>
<p>With this relationship setup we can create new satisfaction ranking like this:</p>
<pre><code class="language-ruby">    prod = Product.first
    buy = Buyer.find_by(name: &quot;Joe&quot;)
    sat = prod.satisfactions.new(rank: 2)
    sat.buyer = buy
    sat.save
</code></pre>
<p>In addition, we could also setup the buyer and product for the new satisfaction ranking in one fell swoop:</p>
<pre><code class="language-ruby">  prod = Product.first
  buy = Buyer.first
  prod.satisfactions.create!(rank: 5, buyer: buy)
</code></pre>
<p>Using these tables, we can find the buyers for a product like this:</p>
<pre><code class="language-ruby">  # Find the product:
  prod = Product.first

  # Find satisfaction rankings attached to the product we just queried:
  # 'sat' now holds an array list of satisfaction rank objects
  sat = prod.satisfactions

  # Now we can use a loop to get the 'buyer' associated with each satisfaction like this:
  # This results in 1+n queries:
  sat.each { |s| s.buyer.name }

  # This will end up running some queries like this:
  # SELECT  &quot;buyers&quot;.* FROM &quot;buyers&quot; WHERE &quot;buyers&quot;.&quot;id&quot; = ? LIMIT ?
  # SELECT  &quot;buyers&quot;.* FROM &quot;buyers&quot; WHERE &quot;buyers&quot;.&quot;id&quot; = ? LIMIT ?
  # SELECT  &quot;buyers&quot;.* FROM &quot;buyers&quot; WHERE &quot;buyers&quot;.&quot;id&quot; = ? LIMIT ?
  # SELECT  &quot;buyers&quot;.* FROM &quot;buyers&quot; WHERE &quot;buyers&quot;.&quot;id&quot; = ? LIMIT ?
  # SELECT  &quot;buyers&quot;.* FROM &quot;buyers&quot; WHERE &quot;buyers&quot;.&quot;id&quot; = ? LIMIT ?
</code></pre>
<p>Instead of having to get a list of the satisfaction rankings assigned to a particular product, and then loop through each one to find the user associated with each one (1+n queries), we can instead use a through association with rails. This will drastically reduce the number of queries that are necessary.</p>
<p>To setup a through association for our current example, we can add this to the 'Product' model:</p>
<h4>Product Model:</h4>
<pre><code class="language-ruby">  class Product &lt; ApplicationRecord
    has_many :satisfactions

    # Add this line:
    has_many :buyers, through: :satisfactions
  end

  # This will allow this query:
  p = Product.first
  p.buyers

  # Resultant query:
  # SELECT &quot;buyers&quot;.* FROM &quot;buyers&quot; INNER JOIN &quot;satisfactions&quot; ON &quot;buyers&quot;.&quot;id&quot; = &quot;satisfactions&quot;.&quot;buyer_id&quot; WHERE &quot;satisfactions&quot;.&quot;product_id&quot; = ?
</code></pre>
<p>To setup the reverse of this relationship, we can add the line below to the 'Buyer' model:</p>
<h4>Buyer Model:</h4>
<pre><code class="language-ruby">  class Buyer &lt; ApplicationRecord
    has_many :satisfactions, dependent: :destroy
    has_many :products, through: :satisfactions
  end

  # This will allow this query:
  buy = Buyer.first
  buy.products
</code></pre>
<p>We can even abbreviate the name of our through association relationship by adding a 'source' declaration and changing our 'Product' model as listed below:</p>
<h4>Product Model:</h4>
<pre><code class="language-ruby">  class Product &lt; ApplicationRecord
    has_many :satisfactions

    # Add this line:
    has_many :purchasers, through: :satisfactions, source: :buyer
  end

  # Now we can do this:
  p = Product.first
  p.purchasers

  # SQL:
  # SELECT &quot;buyers&quot;.* FROM &quot;buyers&quot; INNER JOIN &quot;satisfactions&quot; ON &quot;buyers&quot;.&quot;id&quot; = &quot;satisfactions&quot;.&quot;buyer_id&quot; WHERE &quot;satisfactions&quot;.&quot;product_id&quot; = ?
</code></pre>
<p>We can do the same thing in the reverse as well, by modifying the 'Buyer' model file:</p>
<pre><code class="language-ruby">  class Buyer &lt; ApplicationRecord
    has_many :satisfactions, dependent: :destroy
    has_many :things, through: :satisfactions, source: :product

    # This allows for:
    b = Buyer.first
    b.things

    # SQL:
    # SELECT &quot;products&quot;.* FROM &quot;products&quot; INNER JOIN &quot;satisfactions&quot; ON &quot;products&quot;.&quot;id&quot; = &quot;satisfactions&quot;.&quot;product_id&quot; WHERE &quot;satisfactions&quot;.&quot;buyer_id&quot; = ?
  end
</code></pre>
<p>I have included the code for this mvc application in this repo:
<a href="https://github.com/joshayoung/many-to-many-rails'%3Emany-to-many-rails">many-to-many-rails</a>.</p>
 blas
    </main>
</html>
